# Design_Pattern_Study

  head first Design_Pattern 책 참조.

1. 스트래티지 패턴
2. 옵저버 패턴
3. 데코레이터 패턴
4. 팩토리 패턴
5. 싱글턴 패턴
6. 커맨드 패턴
7. 어댑터 패턴과 퍼사드 패턴
8. 템플릿 메소드 패턴
9. 이터레이터와 컴포지트 패턴
10. 스테이트 패턴
11. 프록시 패턴
12. 컴파운드 패턴

#### 객체지향의 기초
 1. 추상화
 2. 캡슐화
 3. 다형성
 4. 상속

#### 객체지향 원칙
- 바뀌는 부분은 캡슐화한다.
- 상속보다는 구성을 활용한다.
- 구현이 아닌 인터페이스를 맞춰서 프로그래밍한다.

### 1. 스트래티지 패턴(Strategy Pattern)
 - 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트래티지를 활용하면 알고리즘을 사용하는 클라이언와는 독립적으로 알고리즘을 변경 할수 있다.

### 2. 옵저버 패턴(Observer Pattern)
 - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many)의존성을 정의합니다.

  #참고

  1.옵저버 패턴은 그 둘은 상호작용을 하긴 하지만 서로에 대해 서로 잘 모른다라는 느슨한 결합(Loose coupling)을 이루고있다.

  2.java.util.Observable의 단점으로, 이는 인터페이스가 아니라 클래스인 데다가, 어떤 인터페이스를 구현하는 것이 아님,
  Observable은 클래스입니다. 때문에 서브클래스를 만들어야한다는 문제가 발생함. 그래서 재사용성에 제약이 생김//
  클래스의 핵심메소드를 외부에서 호출할수 없음.


##### 옵저버 패턴에서의 디자인 원칙
   1. 애플리케이션에서 바뀌는 부분을 찾아내서 바뀌지 않는 부분으로부터 분리시킨다.

   -> 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식입니다. 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있습니다. 나중에 바뀔 것에 대비해 두면 이렇게 편하게 작업할 수 있습니다.

   2. 특정 구현이 아닌, 인터페이스에 맞춰서 프로그래밍한다.

   -> Subject와 Observer에서 모두 인터페이스를 사용했습니다. Subject에서는 Subject인터페이스를 통해서 Observer인터페이스를 구현하는 객체들의 등록/탈퇴를 관리하고, 그런 객체들한테 연락을 돌리지요. 지금까지 우리가 봐왔던 것처럼, 이렇게 함으로써 결합을 느슨하게 만들 수 있습니다.

   3. 상속보다는 구성을 활용합니다.

   -> 옵저버 패턴에서는 구성을 활용하여, 옵저버들을 관리합니다. 주제와 옵저버 사이의 관계는 상속이 아니라 구성에 의해서 이루어지니까요. 게다가 실행중에 구성되는 방식을 사용하니까 더할 나위 없이 좋겠죠.
